\section{Method}
This paper will analyse an implementation of the REST trajectory compression algorithm using different algorithms for the distance function in the DTW and experiment with different parameters. Additionally experiments will be conducted for an indexing structure for the compressed trajectories. This will enable using and querying the data without decompression. The indexing structure will be created as a hybrid of FlatGeoBuf and the structure of REST output.

\subsection{Indexing Structue for REST}
The main elements will be two flatbuffers; one containing all reference trajectories, and another containing the "compression mapping". A compressed trajectory consists of the id, and the sequence of reference trajectories, all compressed trajectories and their corresponding sequences of reference trajectories will be called the compression mapping. This is because the sequences only store the reference trajectories as references, not the values of them, hence they are mapped together.

To further improve the query performance the structure will implement spatial indexing. However, as in FlatGeoBuf, spatial indexing will be optional as it requires more resources on creation. The spatial indexing will similarily to FlatGeoBuf be done with Packed Hilbert R-trees, because they have shown good results previously.

\subsection{Datasets}
To conduct experiments on different compression algorithms we require data, preferrably multiple large datasets. The motivation for having multiple datasets is that results across varying data is more reliable than results for homogenous data. Good results for a variety of data is also more likely to be applicable for the industry as a whole. Additionally reproducability is important for the validation of results. Therefore we have chosen to use the openly available taxi datasets ROMA from \cite{roma} and PORTO from \cite{porto}. The data conains spatial coordinates from road networks. This means many trajectories or sub-trajectories will be very similar. Therefore this data is a good option for compression.

\subsubsection{ROMA}
This dataset contains mobility traces from taxis driving in the center of Rome. The traces were collected in february of 2014, using the position of the drivers phone approximately every 7 seconds. This was recorded for 316 different taxi drivers for 30 days, resulting in 21 million data points. The data rows contain $driver\_id$, $timestamp$ (seconds), and $position$, $position$ is on the form $(latitude, longitude)$. This means the data is not separated into individual taxi trips but simply represents the location of the driver at that timestamp, regardless if the driver is transporting a passenger, waiting, or driving to pick someone up. Through some data analysis we see that there is some variation in the frequency of location reports, but most timestamps have a 5-15 second gap between them. However, there are some large gaps (e.g. several hours) in the timestamps, likely from breaks in work time or problems with the phone. Therefore we will split timestamps differences above a certain threshold into different trajectories, because we want to have geodata representing continous movement.

\subsubsection{PORTO}
This dataset contains the trajectories for all the taxi trips in the city of Porto, in Portugal over the course of a year, from 01/07/2013 to 30/06/2014. The data was recorded using mobile data terminals installed in the vehicles. In contrast to the ROMA dataset these trajectories are grouped by taxi trips for a total of 1.7 million taxi trips. This dataset also contains some additional metadata for each trip, however for the purpose of this paper we will only consider the geodata. We will look at the fields $trip\_id$, $driver\_id$, $timestamp$, and $polyline$. Another key difference from ROMA is that the PORTO data does not include timestamps for each location in the trajectory, but for the beginning of the trajectory itself. This means spatiotemporal analysis of individual points will not be possible for the PORTO dataset.
