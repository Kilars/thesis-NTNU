For the trajectory compression we implemented Greedy Spatial Compression (GSC) from REST. This is an algorithm that compresses trajectories using a reference set. It compresses by converting trajectories into sequences of references and "direct points", known as the compression sequence. The references are pointers to subtrajectories in the reference set that match some part of the trajectory. The reference is considered the compression of the part of the trajectory it represents. They are called \textit{Matchable Reference Trajectories} and the definition is taken directly from \textcite{zhao2018rest}.
\begin{quote}
    \begin{definition}
        \label{def:mrt}
        Matchable Reference Trajectory (MRT). \textit{Given a sub-trajectory T(i, j) and a spatial deviation threshold $\epsilon_{s}$, its matchable reference trajectory set, denoted as M(T(i, j)), includes all the reference sub-trajectories with less-than-$\epsilon_{s}$ MaxDTW distance with T(i, j), i.e.,}
    \end{definition}
\end{quote}
\begin{equation}\label{eq:mrt}
    \begin{align*}
        \hspace*{-3cm} M(T(i,j)) = \{ & \mathbb{T}(k,g) \mid \mathbb{T} \in \mathcal{R}, i \leq k \leq g \leq \left\lvert \mathbb{T} \right\rvert, \\
        \hspace*{-3cm}                & \text{MaxDTW}(T(i,j), \mathbb{T}(k,g)) \leq \epsilon_{s} \}
    \end{align*}
\end{equation}

From this and the properties of MaxDTW, \textcite{zhao2018rest} also derived a rule.

\begin{quote}
    \label{lemma}
    Lemma 1. \textit{Any sub-trajectory of the MRT of T(i, j) is also an MRT of sub-trajectory of T(i, j).}
\end{quote}


With the definition of an MRT and Lemma 1, the GSC algorithm can be further explained. To compress a trajectory $T = [t_0, t_1, ..., t_n]$ GSC, searches for MRTs for $T$. The subtrajectories of $T$ with no MRTs are not compressed, but stored directly in the compression sequence. The amount of subtrajectories with no MRTs depends on the coverage of the reference set. GSC's goal is to represent $T$ with as few MRTs as possible. Consequently, it attempts to use MRTs for as long subtrajectories as possible.

However, GSC searches for the matches greedily. Greedy in the sense that it selects the longest subtrajectory with an MRT originating from the first point. GSC starts by finding MRTs for the subtrajectory $[t_0, t_1]$, and uses these to find MRTs for $[t_0, t_1, t_2]$. In contrast, an optimal solution would also consider using MRTs for subtrajectories originating in a point other than $t_0$, as it might lead to a more efficient compression.

The is search method is called \textit{greedy\_mrt\_expand} and the source code for this can be seen in code listing \ref{lst:ca_expand}. The function's input and output is shown in line 1-6, it has 4 input parameters:

\input{pseudo/greedy_mrt_expand.tex}

\begin{itemize}
    \item{\textit{t} - The trajectory being compressed}
    \item{\textit{candidate\_reference\_trajectories} - The reference trajectories used in compression}
    \item{\textit{spatial\_deviation} - The spatial deviation threshold for MRTs}
\end{itemize}

The output is a tuple (\textit{m}, $r_{0,m}$) or None. Where \textit{m} is the last index of the subtrajectory corresponding to the MRT and $r_{0,m}$ is the MRT itself. The compressed subtrajectory is given by [$t_0$, ..., $t_m$], the first index is always 0 because of the greedy search strategy. The compressed subtrajectory is the longest subtrajectory with an MRT from the \textit{candidate\_reference\_trajectories}. The input \textit{candidate\_reference\_trajectories} is either the entire reference set, or a subset of the reference set created using a spatial filter, this is discussed in section \ref{sec:sf}. None is returned if no MRTs were found.

Line 7 in code listing \ref{lst:ca_expand} is the start of the function and initializes a map for (subtrajectory, MRT) tuples. Line 8-47 is the code block for search in each reference trajectory \textit{rt}. It initializes \textit{current\_mrts} with all length two MRTs for [$t_0$, ..., $t_i$] where $i = 1$ (line 9-15). It does this by calculating the Max DTW distance between [$t_0$, $t_1$] and subtrajectories [$rt_j$, $rt_{j+1}$] for $j = 0, 1, ..., m-2$, where $m$ is the length of the $rt$. $current\_mrts$ is the collection of all MRTs for [$t_0$, $t_1$]. It follows from \hyperref[lemma]{Lemma 1} that this will be the basis for all MRTs. This is because the Max DTW distance can never decrease for a longer subtrajectory.

The loop in line 17-47 uses $current\_mrts$ to find MRTs for $st_{i+1}$ = [$t_0$, ..., $t_{i+1}$] and stores MRTs to the global set (line 20-26). For each $rt$ = [$rt_0$, ..., $rt_m$] in $current\_mrts$ (matches for $st_i$), three expansions are tested for a match with $st_{i+1}$:
\begin{itemize}
    \item {[$rt_0$, ..., $rt_m$]}
    \item {[$rt_m$, ..., $rt_{m+1}$]}
    \item {[$rt_0$, ..., $rt_{m+1}$]}
\end{itemize}
This is in accordance with the expansion in the original REST mrt\_search algorithm, from \textcite{zhao2018rest}. The loop continues, increasing $i$ for each iteration, as long as an MRT can be found for $st_{i+1}$ or until $i+1 = |st|$. In addition, an arbitrary match from the $current\_mrts$ is added to the global map if no entry exists for $st_{i}$, for each iteration. When this loop finishes, the algorithm repeats the process for the next reference trajectory. In the end, on line 50 the (subtrajectory_index, MRT) tuple for the longest subtrajectory from the global map is returned.

% Regarding MRT selection when multiple are available, this was done arbitrarily. From the definition, an MRT has a DTW distance to the subtrajectory being compressed lower than the spatial deviation threshold. This means one reference trajectory can have a lower DTW distance than another, while both are considered MRTs. From this one could argue that the algorithm should select the MRT with the lowest distance. However, this implementation of REST applies bounded lossy compression, which means any result within the threshold is valid or "good enough". Therefore, no resources are spent locating the best MRT within the threshold, even though the resources required aren't large because the DTW distance is calculated anyway. If this were implemented, it could be considered "best effort bounded lossy compression". Comparing that to bounded lossy compression would be interesting, but it was not done due to time constrains. It is also likely that it wouldn't make a large difference because a reference trajectory with a significantly lower DTW distance could also match for a longer subtrajectory. This means that if there were multiple MRTs to select, they are likely close in DTW distance to the relevant subtrajectory. The way the reference trajectories expand and how this effects the DTW distance is further discussed in results and discussion. %Reference definition of spatial greedy compression
%Nuke last part about best effort lossy compression
%Maybe something about arbitrary match from the definition of bounded lossy compression

To compress a whole trajectory, a wrapper function uses greedy\_mrt\_expand iteratively. For instance, say that a trajectory $U = [u_0, ..., u_n]$ where $n = 50$ is being compressed. The first iteration of greedy\_mrt\_expand returns (25, $MRT_1$). Now the wrapper adds $MRT_1$ to the compression sequence, and sends $[u_25 ..., u_n]$ into greedy\_mrt\_expand. The process continues until all points up to $u_n$ are compressed. An example compression sequence could be, $[MRT_1, u_25, u_26, MRT_2]$. In this case $[u_25, u_26]$ had no MRT and was stored directly in the compression sequence.